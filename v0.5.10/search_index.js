var documenterSearchIndex = {"docs":
[{"location":"man/2_run_polyOrigin/#Run-polyOrigin","page":"2 Run polyOrigin","title":"Run polyOrigin","text":"","category":"section"},{"location":"man/2_run_polyOrigin/","page":"2 Run polyOrigin","title":"2 Run polyOrigin","text":"Run function polyOrigin for haplotype reconstruction. Here is a simulated example of a tetraploid population, consists of four subpopulations: three crosses among 3 parents and one selfing of the first parent. The genofile contains genetic map with 120 SNPs and dosage data for 3 parents and 120 offspring.","category":"page"},{"location":"man/2_run_polyOrigin/","page":"2 Run polyOrigin","title":"2 Run polyOrigin","text":"using PolyOrigin\nworkdir = joinpath(pkgdir(PolyOrigin),\"docs\",\"run_polyOrigin\")\ngenofile = \"geno_disturbed.csv\"\npedfile = \"ped.csv\"\noutstem = \"outstem\"\npolyancestry = polyOrigin(genofile,pedfile;\n    chrpairing=44,    \n    isphysmap = false,\n    refinemap=true,\n    refineorder=true,    \n    workdir,\n    outstem,    \n)\nfilter(x->occursin(outstem,x), readdir(workdir))","category":"page"},{"location":"man/2_run_polyOrigin/","page":"2 Run polyOrigin","title":"2 Run polyOrigin","text":"Here chrpairing=44 denotes bivalent and quadrivalent formations in ancestral inference. isphysmap specifies if the input map is a physical map, refinemap specifies if refine the input map and refineorder specifies further if refine only inter-marker distances (refinemap=true and refineorder=false), workdir specifies the directory of input and output files, and outstem specifies the filename stem for output files.","category":"page"},{"location":"man/2_run_polyOrigin/","page":"2 Run polyOrigin","title":"2 Run polyOrigin","text":"The polyOrigin function produces the following outputfiles:","category":"page"},{"location":"man/2_run_polyOrigin/","page":"2 Run polyOrigin","title":"2 Run polyOrigin","text":"outstem.log: log file saves messages that are printed on console.\noutstem_maprefined.csv: same as the input genofile, except that input marker map is refined.\noutstem_parentphased.csv: same as the input genofile, except that parental genotypes are phased.\noutstem_parentphased_corrected.csv: the phased parent genotypes are  corrected.\noutstem_polyancestry.csv: saves the returned variable polyancestry. See also polyOrigin for more details.\noutstem_genoprob.csv: a concise version of the above file, including genetic map, phased parental genotypes, and posterior origin-genotype probabilities.\noutstem_postdoseprob.csv: same as the input genofile, except that  parent genotypes are phased and offspring genotypes are given by the posterior dose probabilities.","category":"page"},{"location":"man/2_run_polyOrigin/","page":"2 Run polyOrigin","title":"2 Run polyOrigin","text":"Here  outstem_maprefined.csv, outstem_parentphased.csv,  outstem_parentphased_corrected.csv, or outstem_postdoseprob.csv may be iteratively used as the input genofile.","category":"page"},{"location":"man/2_run_polyOrigin/#Visualize-conditional-probability","page":"2 Run polyOrigin","title":"Visualize conditional probability","text":"","category":"section"},{"location":"man/2_run_polyOrigin/","page":"2 Run polyOrigin","title":"2 Run polyOrigin","text":"The outstem_polyancestry.csv can be read back by the function readPolyAncestry, and ancestral conditional probability can be visualized by plotCondprob or animCondprob.","category":"page"},{"location":"man/2_run_polyOrigin/","page":"2 Run polyOrigin","title":"2 Run polyOrigin","text":"using PolyOrigin\nworkdir = joinpath(pkgdir(PolyOrigin),\"docs\",\"run_polyOrigin\")","category":"page"},{"location":"man/2_run_polyOrigin/","page":"2 Run polyOrigin","title":"2 Run polyOrigin","text":"polyancestry = readPolyAncestry(\"outstem_polyancestry.csv\",workdir=workdir)\ntruegeno = readTruegeno!(\"true.csv\",polyancestry,workdir=workdir)\nusing Plots\nanimCondprob(polyancestry; truegeno=truegeno,\n    left_margin = 8Plots.mm, bottom_margin = 5Plots.mm)","category":"page"},{"location":"man/2_run_polyOrigin/#Evaluate-estimated-map","page":"2 Run polyOrigin","title":"Evaluate estimated map","text":"","category":"section"},{"location":"man/2_run_polyOrigin/","page":"2 Run polyOrigin","title":"2 Run polyOrigin","text":"Compare input map and estimated map with true map","category":"page"},{"location":"man/2_run_polyOrigin/","page":"2 Run polyOrigin","title":"2 Run polyOrigin","text":"using PolyOrigin\nworkdir = joinpath(pkgdir(PolyOrigin),\"docs\",\"run_polyOrigin\")\ngenofile = \"geno_disturbed.csv\"\npedfile = \"ped.csv\"\npolyancestry = readPolyAncestry(\"outstem_polyancestry.csv\",workdir=workdir)\ntruegeno = readTruegeno!(\"true.csv\",polyancestry,workdir=workdir)","category":"page"},{"location":"man/2_run_polyOrigin/","page":"2 Run polyOrigin","title":"2 Run polyOrigin","text":"polygeno=readPolyGeno(genofile,pedfile,workdir=workdir)\nfig = plotMapComp(truegeno.truemap,polygeno.markermap,\n    xlabel=\"True position (cM)\",\n    ylabel=\"Input position (cM)\")\nfig2 = plotMapComp(truegeno.truemap, polyancestry.markermap,\n    xlabel=\"True position (cM)\",\n    ylabel=\"Estimated position (cM)\")\nusing Plots\nplot(fig,fig2,left_margin = 8Plots.mm, bottom_margin = 5Plots.mm)","category":"page"},{"location":"man/2_run_polyOrigin/","page":"2 Run polyOrigin","title":"2 Run polyOrigin","text":"where tau is the Kendall rank correlation between true map and comparing map.","category":"page"},{"location":"man/2_run_polyOrigin/","page":"2 Run polyOrigin","title":"2 Run polyOrigin","text":"using PolyOrigin\nworkdir = joinpath(pkgdir(PolyOrigin),\"docs\",\"run_polyOrigin\")\noutstem=\"outstem\"\noutfiles = filter(x->occursin(outstem,x), readdir(workdir;join=true))\nrm.(outfiles)","category":"page"},{"location":"man/3_examples/#Examples","page":"3 Examples","title":"Examples","text":"","category":"section"},{"location":"man/3_examples/","page":"3 Examples","title":"3 Examples","text":"See the examples.","category":"page"},{"location":"man/3_examples/","page":"3 Examples","title":"3 Examples","text":"Haplotype reconstruction in a simulated tetraploid multi-parental population from SNP array data","category":"page"},{"location":"man/3_examples/","page":"3 Examples","title":"3 Examples","text":"Haplotype reconstruction in a simulated tetraploid multi-parental population from GBS data","category":"page"},{"location":"man/3_examples/","page":"3 Examples","title":"3 Examples","text":"Haplotype reconstruction in a real 3x3 half-diallel potato population","category":"page"},{"location":"lib/internals/#PolyOrigin-Documentation","page":"Internals","title":"PolyOrigin Documentation","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Documentation for PolyOrigin.jl's internal interface.","category":"page"},{"location":"lib/internals/#Contents","page":"Internals","title":"Contents","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"lib/internals/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"lib/internals/#Internal-Interface","page":"Internals","title":"Internal Interface","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"PolyOrigin.polyPhase\nPolyOrigin.polyPhase!\nPolyOrigin.polyMapRefine!\nPolyOrigin.polyReconstruct!\nPolyOrigin.setAbsPhase!\nPolyOrigin.savegenodata\nPolyOrigin.savegenoprob","category":"page"},{"location":"lib/internals/#PolyOrigin.polyPhase","page":"Internals","title":"PolyOrigin.polyPhase","text":"polyPhase(genofile,pedfile, delimchar=',', missingstring=\"NA\",\n    commentstring=\"#\", keyargs...)\n\nperforms parental phasing and return phasedgeno::PolyGeno with phasedgeno.parentgeno being phased.\n\nPositional arguments\n\ngenofile::AbstractString: filename for genotypic data file.\n\npedfile::AbstractString:  filename for population pedigree.\n\nsee readPolyGeno for the requirements of genofile and pedfile.\n\nKeyword arguments\n\ndelimchar::AbstractChar=',':  text delimiter.\n\nmissingstring::AbstractString=\"NA\": string code for missing value.\n\ncommentstring::AbstractString=\"#\": rows that begins with commentstring will be ignored.\n\nsee keyargs in polyPhase!(polygeno::PolyGeno, keyargs...)\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PolyOrigin.polyPhase!","page":"Internals","title":"PolyOrigin.polyPhase!","text":"polyPhase!(polygeno::PolyGeno, keyargs...)\n\nperforms parental phasing and return phasedgeno::PolyGeno with  phasedgeno.parentgeno and polygeno.parentgeno being phased .\n\nPositional arguments\n\npolygeno::PolyGeno: a struct that stores genotypic data and pedigree info.\n\nKeyword arguments\n\nepsilon::Real=0.01: genotypic error probability.\n\nseqerror::Real=0.001: base sequencing error probability for GBS data.\n\nchrpairing_phase::Integer=22: chromosome pairing in parental phasing, with 22 being only bivalent formations and 44 being bi- and quadri-valent formations.\n\nchrsubset::Union{Nothing,AbstractRange,AbstractVector}=nothing: subset of chromosomes to be considered, with nothing denoting all chromosomes. Delete chromosome indices that are out of range.\n\nsnpsubset::Union{Nothing,AbstractRange,AbstractVector}=nothing: subset of markers to be considered, with nothing denoting all markers. within a chromosome, marker index starts from 1, and marker indices that are larger than the number of markers within the chromosome are deleted.\n\nisparallel::Bool=false: if true, multicore computing over chromosomes.\n\ndelmarker::Bool=true: if true, delete markers during parental phasing.\n\n\"delsiglevel::Real=0.05\": significance level for deleting markers.\n\nmaxstuck::Integer=5: the max number of consecutive iterations that are rejected in a phasing run.\n\nmaxiter::Integer=30: the max number of iterations in a phasing run.\"\n\nminrun::Integer=3: if the min number of phasing runs that are at the same local maximimum or have the same parental phases reaches minrun, phasing algorithm will stop before reaching the maxrun.\n\nmaxrun::Integer=10: the max number of phasing runs.\n\nbyparent::Union{Nothing,Bool}=nothing: if true, update parental phases  parent by parent; if false, update parental phases one subpopulation by subpopulation.  The nothing denotes that it is true if a connected component is a simple F1 cross, and false otherwise.\n\nbyneighbor::Union{Nothing,Bool}=nothing: if ture, udpate the combination of bivalent or multivalents in parents by their neighbors; if false, consider all the possible combinations. The nothing denotes thtat it is true if max ploidy>=6, and false otherwise.\n\nrefhapfile::Union{Nothing,AbstractString} = nothing: reference haplotype file for setting absolute parental phases. It has the same format as the input genofile, except that parental genotypes are phased and offspring genotypes are ignored if they exist.\n\nmissingstring::AbstractString=\"NA\": string code for missing value.\n\noutstem::Union{Nothing,AbstractString}=\"outstem\": stem of output filenames. If nothing, no output files.\n\nlogfile::Union{Nothing,AbstractString,IO}= (outstem===nothing ? nothing : string(outstem,\".log\")): log file or IO for writing log. If nothing, no log file.\n\nworkdir::AbstractString = pwd(): directory for reading and writing files.\n\nverbose::Bool=true: if true, print messages on console.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PolyOrigin.polyMapRefine!","page":"Internals","title":"PolyOrigin.polyMapRefine!","text":"polyMapRefine!(phasedgeno::PolyGeno, keyargs...)\n\nperforms marker map refinning for phasedgeno with phased parent genotypes.     Modifies phasedgeno.markermap into a refined genetic map.\n\nPositional arguments\n\nphasedgeno::PolyGeno: a struct that stores genotypic data and pedigree info.\n\nKeyword arguments\n\nepsilon::Real=0.01: genotypic error probability for offspring phasing.\n\nchrpairing::Integer=44: chromosome pairing in offspring decoding, with 22 being only bivalent formations and 44 being bivalent and quadrivalent formations.\n\nchrsubset::Union{Nothing,AbstractRange,AbstractVector}=nothing: subset of chromosomes to be considered, with nothing denoting all chromosomes. Delete chromosome indices that are out of range.\n\nsnpsubset::Union{Nothing,AbstractRange,AbstractVector}=nothing: subset of markers to be considered, with nothing denoting all markers. within a chromosome, marker index starts from 1, and marker indices that are larger than the number of markers within the chromosome are deleted.\n\nisparallel::Bool=false: if true, multicore computing over chromosomes.\n\nrefineorder::Bool=false: if true, refine marker mordering.\n\nmaxwinsize::Integer=50: max size of sliding windown in map refinning.\n\ninittemperature::Real=4: initial temperature of simulated annealing in map refinning.\n\ncoolingrate::Real=0.5: cooling rate of annealing temperature in map refinning.\n\nstripdis::Real=20: a chromosome end in map refinement is removed if it has a distance gap > stripdis (centiMorgan) and it contains less than 5% markers.\n\nmaxepsilon::Real=0.5: markers in map refinement are removed it they have error rates > maxepsilon.\n\nskeletonsize::Integer=50: the number of markers in the skeleton map that is used to re-scale inter-map distances.\n\nlogfile::Union{AbstractString,IOStream}=string(outstem,\".log\"): output filenames or stream for writing log.\n\nworkdir::AbstractString = pwd(): directory for reading and writing files.\n\nverbose::Bool=true: if true, print messages on console.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PolyOrigin.polyReconstruct!","page":"Internals","title":"PolyOrigin.polyReconstruct!","text":"polyReconstruct!(polygeno::PolyGeno, keyargs...)\n\nperforms ancestral inference from polygeno and return polyancestry::PolyAncestry.\n\nPositional arguments\n\npolygeno::PolyGeno: a struct that stores genotypic data and pedigree info.\n\nKeyword arguments\n\nepsilon::Real=0.01: genotypic error probability for offspring phasing.\n\nseqerror::Real=0.001: base sequencing error probability for GBS data.\n\nchrpairing::Integer=44: chromosome pairing in offspring decoding, with 22 being only bivalent formations and 44 being bivalent and quadrivalent formations.\n\nchrsubset::Union{Nothing,AbstractRange,AbstractVector}=nothing: subset of chromosomes to be considered, with nothing denoting all chromosomes. Delete chromosome indices that are out of range.\n\nsnpsubset::Union{Nothing,AbstractRange,AbstractVector}=nothing: subset of markers to be considered, with nothing denoting all markers. within a chromosome, marker index starts from 1, and marker indices that are larger than the number of markers within the chromosome are deleted.\n\nisparallel::Bool=false: if true, multicore computing over chromosomes.\n\ncorrectthreshold::AbstractFloat=0.15: a candidate marker is selected for parental error correction if the fraction of offspring genotypic error >= correctthreshold.\n\nisplot::Bool=false: if true, plot haploprob for all offspring and save in the folder \"outstem_plots\".\n\noutstem::Union{Nothing,AbstractString}=\"outstem\": stem of output filenames. If nothing, no output files.\n\nlogfile::Union{Nothing,AbstractString,IO}= (outstem===nothing ? nothing : string(outstem,\".log\")): log file or IO for writing log. If nothing, no log file.\n\nworkdir::AbstractString = pwd(): directory for reading and writing files.\n\nverbose::Bool=true: if true, print messages on console.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PolyOrigin.setAbsPhase!","page":"Internals","title":"PolyOrigin.setAbsPhase!","text":"setAbsPhase!(refhapfile,phasedgeno::PolyGeno,io=nothing,verbose=true)\n\nset absolute parental phases, based on the reference haplotype file.\n\nPositional arguments\n\nrefhapfile::AbstractString: reference haplotype file has the same format as the input genofile, except that parental genotypes are phased and offspring genotypes are ignored if they exist.\n\nphasedgeno::PolyGeno: polygeno struct with phased parent genotypes .\n\nKeyward arguments\n\nworkdir::AbstractString = pwd(): directory for reading refhapfile.\n\nio::Union{Nothing,IOStream}: stream for writing log.\n\nverbose::Bool=true: true if print messages on console.\n\n\n\n\n\nsetAbsPhase!(refhapfile, polyancestry,io=nothing,verbose=true)\n\nset absolute parental phases and consistent polyancestry.genoprob and polyancestry.haploprob, based on the reference haplotype file.\n\nPositional arguments\n\nrefhapfile::AbstractString: reference haplotype file has the same format as the input genofile, except that parental genotypes are phased and offspring genotypes are ignored if they exist.\n\npolyancestry::PolyAncestry: polyancestry struct with phased parent genotypes and inference genoprob.\n\nKeyward arguments\n\nworkdir::AbstractString = pwd(): directory for reading trueancestryfile.\n\nio::Union{Nothing,IOStream}: stream for writing log.\n\nverbose::Bool=true: true if print messages on console.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PolyOrigin.savegenodata","page":"Internals","title":"PolyOrigin.savegenodata","text":"savegenodata(outfile,polygeno,missingstring=\"NA\",workdir=pwd())\n\nsaves genotypic data of the struct polygeno into outfile\n\nPositional arguments\n\noutfile::AbstractString: filename for saving results.\n\npolygeno::PolyGeno: a struct returned by readPolyGeno.\n\nKeyward arguments\n\nmissingstring::AbstractString=\"NA\": string code for missing value.\n\nworkdir::AbstractString = pwd(): directory for writing outfile.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#PolyOrigin.savegenoprob","page":"Internals","title":"PolyOrigin.savegenoprob","text":"savegenoprob(outfile,polyancestry,missingstring=\"NA\",workdir=pwd())\n\nsaves polyancestry.genoprob and polyancestry.parentgeno into outfile.\n\nPositional arguments\n\noutfile::AbstractString: filename for saving results.\n\npolyancestry::PolyAncestry: a struct returned by polyOrigin.\n\nKeyward arguments\n\nmissingstring::AbstractString=\"NA\": string code for missing value.\n\nworkdir::AbstractString = pwd(): directory for writing outfile.\n\n\n\n\n\n","category":"function"},{"location":"symbols/","page":"Index","title":"Index","text":"Pages = map(file -> joinpath(\"lib\", file), readdir(\"lib\"))\nOrder = [:type,:function]","category":"page"},{"location":"lib/public/#PolyOrigin-Documentation","page":"Public","title":"PolyOrigin Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Documentation for PolyOrigin.jl's public interface.","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"See the internals section for internal function docs.","category":"page"},{"location":"lib/public/#Contents","page":"Public","title":"Contents","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"PolyOrigin\nPolyGeno\nPolyAncestry\npolyOrigin\npolyOrigin!\nreadPolyGeno\nreadPolyAncestry\nsavePolyAncestry\nplotMapComp\nplotCondprob\nanimCondprob\nreadTruegeno!\ncalAccuracy!","category":"page"},{"location":"lib/public/#PolyOrigin","page":"Public","title":"PolyOrigin","text":"PolyOrigin is a package for haplotype reconstruction in connected polyploid F1 populations. See also: polyOrigin, polyOrigin!.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#PolyOrigin.PolyGeno","page":"Public","title":"PolyOrigin.PolyGeno","text":"PolyGeno\n\nmutable struct that stores genotypic data and pedigree information\n\nPolyGeno(markermap,parentgeno,offspringgeno,parentinfo,offspringinfo,designinfo,delmarker,correction)\n\nconstructor from genotypic data and pedigree information.\n\nFields\n\nmarkermap::Vector{DataFrame}: marker map for each chromosome. markermap[c] gives the dataframe of chromosome c with columns [:marker, :chromosome, :position].\n\nparentgeno::Vector{Matrix}: genotypic data in parents. parentgeno[c][m,i] gives the genotype of parent i at marker m of chromosome c.\n\noffspringgeno::Vector{Matrix}: genotypic data in offspring. offspringgeno[c][m,i]  gives the genotype of offspring i at marker m of chomosome c.\n\nparentinfo::DataFrame: parent information with columns [:individual, :ploidy].\n\noffspringinfo::DataFrame: offspring information with columns [:individual,:population,:isoutlier].\n\ndesigninfo::DataFrame: design information with columns [:population, :parent1, :parent2, ...]. The dataframe element n_ij denotes the nubmer of gametes contributed to each offspring in i-th population by j-th parent. n_ij=2 means that i-th population is produced by self-fertilization of j-th parent. Row sum must be 2.\n\ndelmarker::DataFrame: dataframe for collecting markers that were removed from markermap, in the stages of parental phasing or map refinement. It has columns [:marker, :chromosome, :position].\n\ncorrection::DataFrame: dataframe for collecting parental genotype corrections. It has columns [:round,:marker,:chromosome,:parent,:oldgenotype,:newgenotype,:oldnerr,:newnerr].\n\nnote: Note\nA genotype in offspringgeno must be one of following formats 1-3, and a genotype in parentgeno must be one of following formats 1-4:dosage: ranges from 0, 1, ..., ploidy, and missing for missing dosage;\nreadcount:  [c1, c2] where c1 and c2 are the number of reads for  alleles 1 and 2, respectively. Missing genotypes are denoted by [0,0].\nprobability: [p0, p1, ...], where p_i denotes the probability of observed data given dosage i = 0, ..., ploidy, and the probabilities are normalized so that their sum is 1.\nphasedgeno: [g1, g2,...],  where g_i=1 or 2 for i=1,..., ploidy.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PolyOrigin.PolyAncestry","page":"Public","title":"PolyOrigin.PolyAncestry","text":"PolyAncestry\n\nmutable struct the results of haplotype reconstruction.\n\nPolyAncestry(markermap,parentgeno,parentinfo,offspringinfo,designinfo,\n    statespace,valentprob,genoprob)\n\nConstructor from the results of haplotype reconstruction.\n\nFields\n\nmarkermap::Vector{DataFrame}: marker map for each chromosome. markermap[c] gives the dataframe of chromosome c with columns [:marker, :chromosome, :position].\n\nparentgeno::Vector{Matrix}: genotypic data in parents. parentgeno[c][m,i] gives the genotype of parent i at marker m of chromosome c.\n\nparentinfo::DataFrame: parent information with columns [:individual, :ploidy].\n\noffspringinfo::DataFrame: offspring information with columns [:individual,:population].\n\ndesigninfo::DataFrame: design information with columns [:population, :parent1, :parent2, ...]. The dataframe element n_ij denotes the nubmer of gametes contributed to each offspring in i-th population by j-th parent. n_ij=2 means that i-th population is produced by self-fertilization of j-th parent. Row sum must be 2.\n\ndelmarker::DataFrame: dataframe for collecting markers that were removed from markermap, in the stages of parental phasing or map refinement. It has columns [:marker, :chromosome, :position].\n\ncorrection::DataFrame: dataframe for collecting parental genotype corrections. It has columns [:marker,:chromosome,:parent,:oldgenotype,:newgenotype,:oldnerr,:newnerr].\n\nstatespace::Dict: specify valents and origin-genotypes for each population. Each key is a population id, and its value is in turn a dict with keys: \"parent\", \"parentindex\", \"valent\", \"valentneighbor\", and \"groupstate\".\n\nvalentprob::Union{Nothing,Vector}, posterior valent probability for each offspring in each chromosome. valentprob[c][o] for offspring o in chromsome c is a matrix with three columns being valentindex, loglike, and posterior probability. Here posterior probability is calcuated from loglike, assuming a discrete uniform prior distribution of valent configurations.\n\ngenoprob::Vector: posterior origin-genotype probability for each offspring in each chromosome. genoprob[c][o] for offspring o in chromsome c is a sparse matrix, with element (m,s) being the probability of origin-genotype s at marker m.\n\nhaploprob::Union{Nothing,Vector}: posterior origin-haplotype probability for each offspring in each chromosome. haploprob[c][o] for offspring o in chromsome c is a sparse matrix, with element (m,s) being the probability of origin-haplotype s at marker m.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PolyOrigin.polyOrigin","page":"Public","title":"PolyOrigin.polyOrigin","text":"polyOrigin(genofile, pedfile, delimchar=',', missingstring=\"NA\",\n    commentstring=\"#\", keyargs...)\n\nperforms parental phasing and ancestral inference from input files and return polyancestry::PolyAncestry. Only ancestral inference is performed in the case of phased parents.\n\nPositional arguments\n\ngenofile::AbstractString: filename for genotypic data file.\n\npedfile::AbstractString:  filename for pedigree info.\n\nsee readPolyGeno for the requirements of genofile and pedfile.\n\nKeyword arguments\n\ndelimchar::AbstractChar=',':  text delimiter.\n\nmissingstring::AbstractString=\"NA\": string code for missing value.\n\ncommentstring::AbstractString=\"#\": rows that begin with commentstring will be ignored.\n\nisphysmap::Bool=false: if true, input markermap is physical map, where marker locations are in unit of base pair(bp).\n\nrecomrate::Real=1: recombination rate in unit of 1 cM/Mbp (centiMorgan per million base pair). Valid only if isphysmap=true.\n\nsee keyargs in polyOrigin!(polygeno::PolyGeno, keyargs...)\n\nOutput files\n\noutstem.log: log file saves messages that were printed on console.\n\noutstem_maprefined.csv: same as the input genofile, except that input marker map is refined.\n\noutstem_parentphased.csv: same as the input genofile, except that parental genotypes are phased.\n\noutstem_parentphased_corrected.csv: parented genotypes are further corrected.\n\noutstem_polyancestry.csv: saves the returned polyancestry. See savePolyAncestry.\n\noutstem_genoprob.csv: a concise version of the above file, including genetic map, phased parental genotypes, and posterior origin-genotype probabilities. See savegenoprob.\n\noutstem_postdoseprob.csv: same as the input genofile, except that  parent genotypes are phased and offspring genotypes are given by the posterior dose probabilities.\n\nExample\n\njulia> polyOrigin(genofile,pedfile)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PolyOrigin.polyOrigin!","page":"Public","title":"PolyOrigin.polyOrigin!","text":"polyOrigin!(polygeno::PolyGeno, keyargs...)\n\nperforms parental phasing and ancestral inference from polygeno and return polyancestry::PolyAncestry. Only ancestral inference is performed in the case of phased parents. See readPolyGeno for creating polygeno from inputfiles.\n\nPositional arguments\n\npolygeno::PolyGeno:  a struct storing genotypic data and pedigree info.\n\nKeyword arguments\n\nepsilon::Real=0.01: genotyping error probability.\n\nseqerr::Real=0.001: sequencing read error probability for GBS data.\n\nchrpairing_phase::Integer=22: chromosome pairing in parental phasing, with 22 being only bivalent formations and 44 being bivalent and quadrivalent formations.\n\nchrpairing::Integer=44: chromosome pairing in offspring decoding, with 22 being only bivalent formations and 44 being bivalent and quadrivalent formations.\n\nchrsubset::Union{Nothing,AbstractRange,AbstractVector}=nothing: subset of chromosome, with nothing denoting all chromosomes. Delete chromosome indices that are out of range.\n\nsnpsubset::Union{Nothing,AbstractRange,AbstractVector}=nothing: subset of markers to be considered, with nothing denoting all markers. within a chromosome, marker index starts from 1, and marker indices that are larger than the number of markers within the chromosome are deleted.\n\nisparallel::Bool=false: if true, multicore computing over chromosomes.\n\ndelmarker::Bool=true: if true, delete markers during parental phasing.\n\ndelsiglevel::Real=0.05: significance level for deleting markers.\n\nmaxstuck::Integer=5: the max number of consecutive iterations that are rejected in a phasing run.\n\nmaxiter::Integer=30: the max number of iterations in a phasing run.\n\nminrun::Integer=3: if the number of phasing runs having the same parental phases reaches minrun, phasing algorithm will stop before reaching the maxrun.\n\nmaxrun::Integer=10: the max number of phasing runs.\n\nbyparent::Union{Nothing,Bool}=nothing: if true, update parental phases parent by parent; if false, update parental phases one subpopulation by subpopulation. The nothing denotes that it is true if a connected component is a single F1 cross, and false otherwise.\n\nbyneighbor::Union{Nothing,Bool}=nothing: if ture, udpate the combination of bivalent or multivalents in parents by their neighbors; if false, consider all the possible combinations. The nothing denotes that it is true if max ploidy>=6, and false otherwise.\n\nrefhapfile::Union{Nothing,AbstractString} = nothing: reference haplotype file for setting absolute parental phases. It has the same format as the input genofile, except that parental genotypes are phased and offspring genotypes are ignored if exist.\n\ncorrectthreshold::AbstractFloat=0.15: a candidate marker is selected for parental error correction if the fraction of offspring genotypic error >= correctthreshold.\n\nrefinemap::Bool=false: if true, refine marker map.\n\nrefineorder::Bool=false: if true, refine marker mordering, valid only if refinemap=true\n\nmaxwinsize::Integer=50: max size of sliding windown in map refinning.\n\ninittemperature::Real=4: initial temperature of simulated annealing in map refinning.\n\ncoolingrate::Real=0.5: cooling rate of annealing temperature in map refinning.\n\nstripdis::Real=20: a chromosome end in map refinement is removed if it has a distance gap > stripdis (centiMorgan) and it contains less than 5% markers.\n\nmaxepsilon::Real=0.5: markers in map refinement are removed it they have error rates > maxepsilon.\n\nskeletonsize::Integer=50: the number of markers in the skeleton map that is used to re-scale inter-map distances.\n\nmissingstring::AbstractString=\"NA\": string code for missing value.\n\nisplot::Bool=false: if true, plot condprob for all offspring and save in the folder \"outstem_plots\".\n\noutstem::Union{Nothing,AbstractString}=\"outstem\": stem of output filenames. If nothing, no output files.\n\nlogfile::Union{Nothing,AbstractString,IO}= (outstem===nothing ? nothing : string(outstem,\".log\")): log file or IO for writing log. If nothing, no log file.\n\nworkdir::AbstractString = pwd(): directory for reading and writing files.\n\nverbose::Bool=true: if true, print messages on console.\n\nExample\n\njulia> polygeno = readPolyGeno(genofile,pedfile)\njulia> polyOrigin!(polygeno)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PolyOrigin.readPolyGeno","page":"Public","title":"PolyOrigin.readPolyGeno","text":"readPolyGeno(genofile, pedfile, keyargs...)\n\nreads input files and returns polygeno::PolyGeno.\n\nPositional arguments\n\ngenofile::AbstractString: filename for genotypic data. For example, a CSV formatted genofile looks like\n\n    marker, chromosome, pos, ind1,ind2, ind3, ...\n    snp1, 1, 0.14, 0, 2, 1, 4, ...\n    snp2, 1, 0.16, 4, 0, NA, 2, ...\n    snp3, 1, 0.21, NA, 3, 0, 1, ...\n\nnote: Note\nThe first three columns specify the genetic map. Marker IDs in column 1 must be unique, chromosome IDs in column 2 must be consecutive, and positions (in unit of centi-Morgan or base pair) of markers in column 3 must be non-descreasing within a chromosome.\nThe rest of columns give the genotypes of sampled individuals. The indvidual IDs must be unique. The genotypes of all parents must be represented by one of the following formats 1-4, and the genotypes of all offspring must be represented by one of the following formats 1-3.\ndosage: ranges from 0, 1, ..., ploidy, and NA for missing dosage;\nreadcount: c1|c2, where c1 and c2 are the number of reads for alleles 1 and 2, respectively. Missing genotypesare given by 0|0\nprobability: p(0)|p(1)|...|p(ploidy), where p(i) denotes the probability  of observed data given dosage i = 0, ..., ploidy, and the probabilities  are normalized so that their sum is 1.\nphasedgeno: g(1)|g(2)|...|g(ploidy),  where g(i)=1 or 2 for i=1,..., ploidy.\nAll individuals must be in the pedfile.\n\npedfile::AbstractString: filename for pedigree information. For example, a CSV formatted pedfile looks like\n\n    individual, population, motherid, fatherid, ploidy\n    P1, 0, 0, 0, 4\n    P3, 0, 0, 0, 4\n    P3, 0, 0, 0, 4\n    offspring1, pop1, P1, P2, 4\n    offspring2, pop1, P1, P2, 4\n    offspring3, pop2, P1, P3, 4\n    offspring4, pop2, P1, P3, 4\n    offspring5, pop3, P2, P3, 4\n    offspring6, pop4, P3, P3, 4\n\nnote: Note\nThe pedigree contains three founders (parents), two offspring from the cross beween parents 1 and 2, two offspring from the cross between parents 1 and 3, one offspring from the cross between parents 2 and 3, and one offspring from the selfing of parent 3.\nAll individual IDs in column 1 must be unique, column 2 denotes ID for the founder population and IDs for each F1 cross or selfing, columns 3 and 4 denotes the parents of each sub-population (motherID and fatherID of founders are set to 0), and column 5 denotes the ploidy level.\nAll parents and all offspring must be in the genofile.\n\nKeyword arguments\n\nmissingstring::AbstractString=\"NA\": string code for missing value.\n\ndelimchar::AbstractChar=',':  text delimiter.\n\ncommentstring::AbstractString=\"#\": rows that begins with commentstring will be ignored.\n\nisphysmap::Bool=false: true if input markermap is physical map, where marker locations are in unit of base pair(bp).\n\nrecomrate::Real=1 recombination rate in unit of 1 cM/Mbp (centiMorgan per million base pair).\n\nworkdir::AbstractString = pwd(): directory for reading genofile and pedfile\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PolyOrigin.readPolyAncestry","page":"Public","title":"PolyOrigin.readPolyAncestry","text":"readPolyAncestry(genoprobfile, pedfile, missingstring=\"NA\",workdir=pwd())\n\nreturn a struct of with type PolyAncestry from  genoprobfile and pedfile     in the directory workdir.\n\nPositional argument\n\ngenoprobfile: file storing conditional genotype probability.\n\npedfile::AbstractString: filename for pedigree information.\n\nKeyword arguments\n\nchrpairing::Integer=44: chromosome pairing that has been used in producing genoprobfile. chrpairing = 22 indicates only bivalent formations and 44 for bivalent and quadrivalent formations.\n\nmissingstring::AbstractString=\"NA\": string code for missing value.\n\ndelimchar::AbstractChar=',':  text delimiter.\n\ncommentstring::AbstractString=\"#\": rows that begins with commentstring will be ignored.\n\nworkdir::AbstractString = pwd(): directory for reading genoprobfile and pedfile\n\n\n\n\n\nreadPolyAncestry(ancestryfile, missingstring=\"NA\",workdir=pwd())\n\nreturn a struct of type PolyAncestry from  ancestryfile in the     directory workdir.\n\nPositional argument\n\nancestryfile: file storing polyancestry that is generated by savePolyAncestry It is one of output files by polyOrigin.\n\nKeyward arguments\n\nmissingstring::AbstractString=\"NA\": string code for missing value.\n\nworkdir::AbstractString = pwd(): directory for reading ancestryfile,\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PolyOrigin.savePolyAncestry","page":"Public","title":"PolyOrigin.savePolyAncestry","text":"savePolyAncestry(outfile,polyancestry,missingstring=\"NA\",workdir=pwd())\n\nsaves polyancestry into outfile in CSV format.\n\nPositional arguments\n\noutfile::AbstractString: file for saving polyancestry in the directory workdir. The saved outfile consists of several tables: the first row of each table has two cells: [PolyOrigin-PolyAncestry, nameoftable], and the rest rows denote a dataframe with column names. The following is a list of table names and their descriptions.\n\ndesigninfo: design information with columns being [population, parent1, parent2, ...]. Matrix element Dij denotes the nubmer of gametes contributed to each offspring in i-th population by j-th parent. Dij=2 means that i-th population is produced by self-fertilization of j-th parent.\nparentinfo: parent information with columns being [individual, ploidy].\noffspringinfo: offspring information with columns being [individual, population, ploidy, isoutlier].\ndelmarker: markers that were removed from markermap, in the stages of parental phasing\n\nor map refinement, with columns being [:marker, :chromosome, :position]\n\ncorrection: parental genotype corrections with columns being\n\n[:round, :marker,:chromosome,:parent,:oldgenotype,:newgenotype,:oldnerr,:newnerr].\n\nvalentlist: list of possible bi- or multi-valent formations for each population. The dataframe has columns [population, parentindex, parent, valentindex, valent].\nvalentprob: posterior valent probability for each offspring in each chromosome. The dataframe has columns [chromosome, individual, population, valentindex, valent, loglike, valentprob].\nparentgeno: phased parental genotypes. The dataframe has columns [marker, chromosome, position, parent1, parent2, ...].\nancestralgenotype: list of origin-genotypes for each population. The dataframe has columns [population, parentindex, parent, stateindex, state]\ngenoprob: marginal posterior probabilities for origin-genotypes. For each offspring at each marker, the posterior probability vector is represented by a sparse vector in the form of I=>V: state index vector I and non-zero probability vector V such that I[k]=V[k] for k=1, ..., K. The elements of vector I or V are delimited by \"|\".\n\npolyancestry::PolyAncestry: results of haplotype reconstruction returned  from polyOrigin.\n\nKeyward arguments\n\nmissingstring::AbstractString=\"NA\": string code for missing value.\n\nworkdir::AbstractString = pwd(): directory for writing outfile.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PolyOrigin.plotMapComp","page":"Public","title":"PolyOrigin.plotMapComp","text":"plotMapComp(mapx, mapy,\n    boundaryline = (1.5,:dot,:black),\n    plotmarker=(:star, 5, 0.5,:blue,stroke(:blue)),\n    isannotate= true,\n    xlabel=\"mapx position\",\n    ylabel=\"mapy position\")\n\nplot postions of mapx vs those of mapx.\n\nPositional arguments\n\nmapx::Vector{DataFrame}: marker map for all chromosomes.\n\nmapy::Vector{DataFrame}: comparing map for all chromosomes.\n\nKeyword arguments\n\nboundaryline=(1.5,:dot,:black): vertical lines for chromosome boundaries.\n\nplotmarker=(:star, 5, 0.5,:blue,stroke(:blue)): scatter markers.\n\nisannotate::Bool=true: if ture,  annotate chromosome ID and kendall correlation.\n\nxlabel::AbstractString=\"mapx position\": axis x label\n\nylabel::AbstractString=\"mapy position\": axis y label\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PolyOrigin.plotCondprob","page":"Public","title":"PolyOrigin.plotCondprob","text":"plotCondprob(polyancestry,offspring=nothing,ishaploprob=true,\n    colorgradient = ColorGradient([:white,:blue,:red]),\n    boundaryline = (1.5,:dot,:black),\n    truemarker=(:star, 5, 0.5,:gray,stroke(:gray)),\n    truegeno=nothing)\n\nplot heatmap for conditional probability.\n\nPositional arguments\n\npolyancestry::PolyAncestry: polyancestry returned from polyOrigin.\n\nKeyword arguments\n\noffspring::Union{Nothing,Integer}=nothing: offsprign index and random offspring by default.\n\ncolorgradient::ColorGradient=ColorGradient([:white,:blue,:red]): color gradient for heatmap\n\nleft_margin = :match: Specifies the extra padding to the left of the subplot\n\nbottom_margin = :match: Specifies the extra padding to the bottom of the subplot\n\nboundaryline=(1.5,:dot,:black): vertical lines for chromosome boundaries.\n\ntruemarker=(:star, 5, 0.5,:gray,stroke(:gray)): scatter markers for true ancestral states.\n\ntruegeno::Union{Nothing,NamedTuple}: provides true parental origins. It is generated by readTruegeno!.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PolyOrigin.animCondprob","page":"Public","title":"PolyOrigin.animCondprob","text":"animCondprob(polyancestry,fps=1,outfile=nothing,kewargs...)\n\nanimation for plots of conditional probability.\n\nPositional arguments\n\npolyancestry::PolyAncestry: polyancestry returned from polyOrigin.\n\nKeyword arguments\n\nfps::Real=1: number of frames per seconds.\n\noutfile::AbstractString=\"condprob.gif\": output file for saving animation.\n\nsee plotCondprob for keyargs.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PolyOrigin.readTruegeno!","page":"Public","title":"PolyOrigin.readTruegeno!","text":"readTruegeno!(truefile,polyancestry, keyargs...)\n\nreturned truegeno of NamedTuple with truegeno.parentgeno storing phased parental genotypes, and truegeno.offspringgeno storing true parental origins. polyancestry is modified (1) extra markers in truefile are put into polyancestry.delmarker, (2) absolute phase of polyancestry.parentgeno is set according to truegeno.parentgeno, and (3) polyancestry.genoprob and polyancestry.haploprob are set to be consistent with the absolute phase.\n\nPositional arguments\n\ntruefile::AbstractString: file storing true values, which has the same requirement as the genofile. The parental genotypes must be given in the phasedgeno  format with alleles being \"1\" and \"2\". The offspring origin-genotypes must be given in the phasedgeno  format with allels being parental homologs.\n\npolyancestry::PolyAncestry: for checking the consistency of marker IDs, chromosome IDs, and individual IDs.\n\nKeyword arguments\n\ndelimchar::AbstractChar=',':  text delimiter.\n\ncommentstring::AbstractString=\"#\": rows that begins with commentstring will be ignored.\n\nworkdir::AbstractString = pwd(): directory for reading truevalue file.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PolyOrigin.calAccuracy!","page":"Public","title":"PolyOrigin.calAccuracy!","text":"calAccuracy!(truefile,polyancestry,workdir=pwd(),io=nothing,verbose=true)\n\ncalculate phasing and ancestral inference accuracies accoring to the true values in truefile. The polyancestry is modified with absolute parental phases and consistent genoprob.\n\nPositional arguments\n\ntruefile::AbstractString: contains true values for parental phases and ancestral genotypes.\n\npolyancestry::PolyAncestry: a struct returned by polyOrigin.\n\nKeyward arguments\n\nworkdir::AbstractString = pwd(): directory for writing outfile.\n\nio::Union{Nothing,IOStream}: stream for writing log.\n\nverbose::Bool=true: true if print messages on console.\n\n\n\n\n\ncalAccuracy!(truegeno,polyancestry,io=nothing,verbose=true)\n\ncalculate phasing and ancestral inference accuracies accoring to the true values in truegeno. The polyancestry is modified with absolute parental phases and consistent genoprob.\n\nPositional arguments\n\ntruegeno::NamedTuple: contains true values for parental phases and ancestral genotypes, returned by readTruegeno!.\n\npolyancestry::PolyAncestry: a struct returned by polyOrigin.\n\nKeyward arguments\n\nio::Union{Nothing,IOStream}: stream for writing log.\n\nverbose::Bool=true: true if print messages on console.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PolyOrigin","category":"page"},{"location":"#PolyOrigin.jl","page":"Home","title":"PolyOrigin.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Haplotype reconstruction in connected polyploid F1 populations","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Apply to connected F1 in tetraploid (TODO for higher ploidy levels)\nApply to SNP array and GBS data\nRobust to dosage errors in SNP array data\nRobust to dosage uncertainties in low coverage GBS data\nRobust to errors in input genetic or physical map","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From the julia (>v1.5.0, 64-bit) REPL model, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"add https://github.com/chaozhi/PolyOrigin.jl","category":"page"},{"location":"#Citing-PolyOrigin.jl","page":"Home","title":"Citing PolyOrigin.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use PolyOrigin in your analyses and publish your results, please cite the article:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Zheng C, Amadeu RR, Munoz PR, and Endelman JB. 2020. Haplotype reconstruction in connected tetraploid F1 populations. doi: https://doi.org/10.1101/2020.12.18.423519.","category":"page"},{"location":"man/0_get_started/#Get-started","page":"0 Get started","title":"Get started","text":"","category":"section"},{"location":"man/0_get_started/#Installation","page":"0 Get started","title":"Installation","text":"","category":"section"},{"location":"man/0_get_started/","page":"0 Get started","title":"0 Get started","text":"From the julia (>v1.5.0, 64-bit) REPL model, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"man/0_get_started/","page":"0 Get started","title":"0 Get started","text":"add https://github.com/chaozhi/PolyOrigin.jl","category":"page"},{"location":"man/0_get_started/#Usage","page":"0 Get started","title":"Usage","text":"","category":"section"},{"location":"man/0_get_started/","page":"0 Get started","title":"0 Get started","text":"To use PolyOrigin.jl in your project,","category":"page"},{"location":"man/0_get_started/","page":"0 Get started","title":"0 Get started","text":"using PolyOrigin","category":"page"},{"location":"man/0_get_started/","page":"0 Get started","title":"0 Get started","text":"To use PolyOrigin.jl with parallel computation of n workers at chromosome level","category":"page"},{"location":"man/0_get_started/","page":"0 Get started","title":"0 Get started","text":"using Distributed\naddprocs(n)\n@everywhere using PolyOrigin","category":"page"},{"location":"man/0_get_started/","page":"0 Get started","title":"0 Get started","text":"and set isparallel=true in function polyOrigin. See addprocs for launching worker processes via the specified cluster manager or on remote machines via SSH.","category":"page"},{"location":"man/1_prepare_input/#Prepare-input","page":"1 Prepare input","title":"Prepare input","text":"","category":"section"},{"location":"man/1_prepare_input/","page":"1 Prepare input","title":"1 Prepare input","text":"The input files of function polyOrigin are two text files: genofile and pedfile. The input files are  in CSV format; set the option delimchar for a different delimiter.","category":"page"},{"location":"man/1_prepare_input/#Input-genofile","page":"1 Prepare input","title":"Input genofile","text":"","category":"section"},{"location":"man/1_prepare_input/","page":"1 Prepare input","title":"1 Prepare input","text":"The genofile stores genetic map, parent genotypes, and offspring genotypes. Click to download zipped example genofile. For example, a genofile looks like","category":"page"},{"location":"man/1_prepare_input/","page":"1 Prepare input","title":"1 Prepare input","text":"marker chromosome position ind1 ind2 ind3 ind4 ...\nsnp1 1 0.14 0 2 1 4 ...\nsnp2 1 0.16 4 0 NA 2 ...\nsnp3 1 0.21 NA 3 0 1 ...","category":"page"},{"location":"man/1_prepare_input/","page":"1 Prepare input","title":"1 Prepare input","text":"The genofile must pass the following check list","category":"page"},{"location":"man/1_prepare_input/","page":"1 Prepare input","title":"1 Prepare input","text":"Column 1: SNP IDs must be unique.\nColumn 2: SNPs must be grouped by chromosome IDs.\nColumn 3: Positions of markers within a chromosome must be non-decreasing. The position unit must be base-pair for physical map and centiMorgan for genetic map.\nRow 1, Col 4-end: Individual IDs must be unique, and must be in pedfile.\nRow 2:end, Col 4-end: all genotypes of parents must take on one of the following formats 1-4, and all genotypes of offspring must take one of the following formats 1-3.","category":"page"},{"location":"man/1_prepare_input/","page":"1 Prepare input","title":"1 Prepare input","text":"List of four possible format of genotypes:","category":"page"},{"location":"man/1_prepare_input/","page":"1 Prepare input","title":"1 Prepare input","text":"dosage: ranges from 0, 1, ..., ploidy, and NA for missing dosage;\nreadcount: c1|c2, where c1 and c2 are the number of reads for alleles 1 and 2, respectively. Missing genotypes are denoted by 0|0\nprobability: p(0)|p(1)|...|p(ploidy), where p(i) denotes the probability of observed data given dosage i = 0, ..., ploidy, and the probabilities are normalized so that their sum is 1.\nphasedgeno: g1|g2|...|g(ploidy),  where g(i)=1 or 2 for i=1, ..., ploidy.","category":"page"},{"location":"man/1_prepare_input/#Input-pedfile","page":"1 Prepare input","title":"Input pedfile","text":"","category":"section"},{"location":"man/1_prepare_input/","page":"1 Prepare input","title":"1 Prepare input","text":"The pedfile stores pedigree information. Click to download zipped example pedfile. For example, a pedfile looks like","category":"page"},{"location":"man/1_prepare_input/","page":"1 Prepare input","title":"1 Prepare input","text":"individual population motherid fatherid ploidy\nP1 0 0 0 4\nP3 0 0 0 4\nP3 0 0 0 4\noffspring1 pop1 P1 P2 4\noffspring2 pop1 P1 P2 4\noffspring3 pop2 P1 P3 4\noffspring4 pop2 P1 P3 4\noffspring5 pop3 P2 P3 4\noffspring6 pop4 P3 P3 4","category":"page"},{"location":"man/1_prepare_input/","page":"1 Prepare input","title":"1 Prepare input","text":"The pedigree contains three founders (parents), two offspring from the cross between parents 1 and 2, two offspring from the cross between parents 1 and 3, one offspring from the cross between parents 2 and 3, and one offspring from the selfing of parent 3.","category":"page"},{"location":"man/1_prepare_input/","page":"1 Prepare input","title":"1 Prepare input","text":"The pedfile must pass the following check list","category":"page"},{"location":"man/1_prepare_input/","page":"1 Prepare input","title":"1 Prepare input","text":"Column 1: individual IDs must be unique, and must be in genofile.\nColumn 2: Unique ID for each sub-population (F1 cross or selfing). The sub-population of founders must be the same.\nColumn 3-4: parentID of founders must be 0.\nColumn 5: ploidy must be 4. TODO for n=2, 4, 6, and 8.","category":"page"}]
}
